<!DOCTYPE html>
<html lang="en">
<head>
<title>OOP in Ruby</title>
<link rel="stylesheet" href="/cfg/format2.css" type="text/css">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="keywords" content="Ruby, OOP, object-oriented programming, 
programming, language, learn Ruby">
<meta name="description" content="In this part of the Ruby tutorial, we cover Object-oriented programming.">
<meta name="author" content="Jan Bodnar">

</head>

<body>

<div class="container">

<div id="wide_ad" class="ltow">
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 160x600, August 2011 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9706709751191532"
     data-ad-slot="2484182563"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>


<div class="content">

<header>

<nav>
<a href="/" title="Home">Home</a>
<a href="..">Contents</a>

<div class="nav_r">
<a href="../hashes/">Previous</a>
<a href="../oop2/">Next</a>
</div>
</nav>

</header>


<h1>Object-oriented programming in Ruby</h1>

<p>
In this part of the Ruby tutorial, we will talk about object-oriented 
programming in Ruby.
</p>

<p>
Programming languages have procedural programming, functional programming and 
object-oriented programming paradigms. Ruby is an object-oriented language with 
some functional and procedural features.
</p>

<div class="big_hor">
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- big_horizontal -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-9706709751191532"
     data-ad-slot="2904953388"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<p>
<em>Object-oriented programming (OOP)</em> is a programming paradigm that uses objects
and their interactions to design applications and computer programs.
</p>

<p>
The basic programming concepts in OOP are:
</p>

<ul>
<li>Abstraction</li>
<li>Polymorphism</li>
<li>Encapsulation</li>
<li>Inheritance</li>
</ul>

<p>
The <em>abstraction</em> is simplifying complex reality by modeling classes 
appropriate to the problem. The <em>polymorphism</em> is the process of using 
an operator or function in different ways for different data input. The <em>encapsulation</em> 
hides the implementation details of a class from other objects. The <em>inheritance</em> 
is a way to form new classes  using classes that have already been defined.
</p>


<h2>Objects</h2>

<p>
Objects are basic building blocks of a Ruby OOP program. 
An object is a combination of data and methods. In a OOP program, 
we create objects. These objects communicate together through methods. 
Each object can receive messages, send messages and process data. 
</p>

<p>
There are two steps in creating an object. First, we define a class. 
A <em>class</em> is a template for an object. It is a blueprint that 
describes the state and behavior that the objects of the class all share. 
A class can be used to create many objects. Objects created at runtime 
from a class are called <em>instances</em> of that particular class. 
</p>

<pre class="code">
#!/usr/bin/ruby

class Being
  
end

b = Being.new
puts b
</pre>

<p>
In our first example, we create a simple object. 
</p>

<pre class="explanation">
class Being
  
end
</pre>

<p>
This is a simple class definition. The body of the template is empty. 
It does not have any data or methods. 
</p>

<pre class="explanation">
b = Being.new
</pre>

<p>
We create a new instance of the Being class. For this we have the 
<code>new</code> method. The b variable stores the newly created object.
</p>

<pre class="explanation">
puts b
</pre>

<p>
We print the object to the console to get some basic description 
of the object. When we print an object, we in fact call its <code>to_s</code> method. But
we have not defined any method yet. It is because every object created
inherits from the base <code>Object</code>. It has some elementary
functionality, which is shared among all objects created. One of this
is the <code>to_s</code> method.
</p>

<pre>
$ ./simple.rb
#&lt;Being:0x9f3c290&gt;
</pre>

<p>
We get the object class name.
</p>


<h2>The constructor</h2>

<p>
A constructor is a special kind of a method. It is automatically called 
when an object is created. Constructors do not return values.
The purpose of the constructor is to initiate the state of an object. 
The constructor in Ruby is called <code>initialize</code>.
Constructors do not return any values. 
</p>

<p>
Constructors cannot be inherited. The constructor of a parent object is called
with a <code>super</code> method. They are called in the order of inheritance.
</p>

<pre class="code">
#!/usr/bin/ruby

class Being

    def initialize
        puts "Being is created"
    end

end

Being.new
</pre>

<p>
We have a Being class. 
</p>

<pre class="explanation">
class Being

    def initialize
        puts "Being is created"
    end

end
</pre>

<p>
The Being class has a constructor method called <code>initialize</code>.
It prints a message to the console. The definition of a Ruby method
is placed between the <code>def</code> and <code>end</code> keywords.
</p>

<pre class="explanation">
Being.new
</pre>

<p>
An instance of the <code>Being</code> class is created. At the moment of the 
object creation, the constructor method is called.
</p>

<pre>
$ ./constructor.rb
Being is created
</pre>

<p>
This is the output of the program. 
</p>


<p>
An object's attributes are the data items that are bundled inside that object.  
These items are also called <em>instance variables</em> or <em>member fields</em>.
An instance variable is a variable defined in a class, for which each object
in the class has a separate copy.
</p>

<p>
In the next example, we initiate data members 
of the class. Initiation of variables is a typical job for constructors. 
</p>

<pre class="code">
#!/usr/bin/ruby

class Person

    def initialize name
        @name = name
    end

    def get_name
        @name
    end

end

p1 = Person.new "Jane"
p2 = Person.new "Beky"

puts p1.get_name
puts p2.get_name
</pre>

<p>
In the above Ruby code, we have a <code>Person</code> class with
one member field. 
</p>


<pre class="explanation">
class Person

    def initialize name
        @name = name
    end
</pre>

<p>
In the constructor of the Person class, we set a member field to a
value name. The name parameter is passed to the constructor at creation.
A constructor is a method called <code>initialize</code>
that is being called at the creation of an instance object. 
The <code>@name</code> is an instance variable. Instance variables start
with <code>@</code> character in Ruby.
</p>

<pre class="explanation">
def get_name
    @name
end
</pre>

<p>
The <code>get_name</code> method returns the member field. In Ruby member 
fields are accessible only via methods.
</p>

<pre class="explanation">
p1 = Person.new "Jane"
p2 = Person.new "Beky"
</pre>

<p>
We create two objects of a <code>Person</code> class. A string parameter is 
passed to each object constructor. The names are stored inside instance variables
that are unique to each object. 
</p>

<pre class="explanation">
puts p1.get_name
puts p2.get_name
</pre>

<p>
We print the member fields by calling the <code>get_name</code> on each of the
objects. 
</p>

<pre>
$ ./person.rb
Jane
Beky
</pre>

<p>
We see the output of the program. Each instance of the <code>Person</code> class 
has its own name member field. 
</p>


<p>
We can create an object without calling the constructor. Ruby
has a special <code>allocate</code> method for this. The
<code>allocate</code> method allocates space for a new object 
of a class and does not call initialize on the new instance. 
</p>

<pre class="code">
#!/usr/bin/ruby

class Being
    
   def initialize
       puts "Being created"
   end   
end


b1 = Being.new
b2 = Being.allocate
puts b2
</pre>

<p>
In the example, we create two objects. The first object using the <code>new</code> method,
the second object using the <code>allocate</code> method.
</p>

<pre class="explanation">
b1 = Being.new
</pre>

<p>
Here we create an instance of the object with the <code>new</code> keyword.
The constructor method <code>initialize</code> is called and the message
is printed to the console.
</p>

<pre class="explanation">
b2 = Being.allocate
puts b2
</pre>

<p>
In case of the <code>allocate</code> method, the constructor is not called.
We call the <code>to_s</code> method with the <code>puts</code> keyword to 
show that the object was created.
</p>

<pre>
$ ./allocate.rb
Being created
#&lt;Being:0x8ea0044&gt;
</pre>

<p>
Here we see the output of the program.
</p>


<h2>Constructor overloading</h2>

<p>
Constructor overloading is the ability to have multiple types of constructors
in a class. This way we can create an object with different number or different
types of parameters. 
</p>

<p>
Ruby <em>has no constructor overloading</em> that we know from some programming
languages. This behaviour can be simulated to some extent with default parameter 
values in Ruby.
</p>

<pre class="code">
#!/usr/bin/ruby


class Person

    def initialize name="unknown", age=0
        @name = name
        @age = age        
    end
    
    def to_s
        "Name: #{@name}, Age: #{@age}"
    end

end

p1 = Person.new
p2 = Person.new "unknown", 17
p3 = Person.new "Becky", 19
p4 = Person.new "Robert"

p p1, p2, p3, p4
</pre>

<p>
This example shows how we could simulate constructor overloading
on a <code>Person</code> class that has two member fields.
When the name parameter is not specified, the string "unknown" is 
used instead. For unspecified age we have 0.
</p>

<pre class="explanation">
def initialize name="unknown", age=0
    @name = name
    @age = age        
end
</pre>

<p>
The constructor takes two parameters. They have a default value.
The default value is used if we do not specify our own values at
the object creation. Note that the order of parameters must be
kept. First comes the name, then the age.
</p>

<pre class="explanation">
p1 = Person.new
p2 = Person.new "unknown", 17
p3 = Person.new "Becky", 19
p4 = Person.new "Robert"

p p1, p2, p3, p4
</pre>

<p>
We create four objects. The constructors take
different number of parameters.
</p>

<pre>
$ ./consover.rb
Name: unknown, Age: 0
Name: unknown, Age: 17
Name: Becky, Age: 19
Name: Robert, Age: 0
</pre>

<p>
This is the output of the example. 
</p>



<h2>Methods</h2>

<p>
Methods are functions defined inside the body of a class. They are used 
to perform operations with the attributes of our objects. Methods are 
essential in the <em>encapsulation</em> concept of the OOP paradigm. 
For example, we might have a connect method in our <code>AccessDatabase</code> class. 
We need not to be informed how exactly the method connects to the database. 
We only have to know that it is used to connect to a database. This is essential 
in dividing responsibilities in programming, especially in large applications. 
</p>

<p>
In Ruby, data is accessible only via methods. 
</p>

<pre class="code">
#!/usr/bin/ruby

class Person

    def initialize name
        @name = name
    end

    def get_name
        @name
    end

end

per = Person.new "Jane"

puts per.get_name
puts per.send :get_name
</pre>

<p>
The example shows two basic ways to call a method. 
</p>

<pre class="explanation">
puts per.get_name
</pre>

<p>
The common way is to use a dot operator on an object 
followed by a method name.
</p>

<pre class="explanation">
puts per.send :get_name
</pre>

<p>
The alternative is to use a built-in <code>send</code> method. 
It takes a symbol of the method to be called as a parameter. 
</p>

<p>
Methods typically perform some action on an object's data.
</p>

<pre class="code">
#!/usr/bin/ruby

class Circle
   
    @@PI = 3.141592

    def initialize
        @radius = 0
    end

    def set_radius radius
        @radius = radius
    end

    def area
        @radius * @radius * @@PI
    end

end


c = Circle.new
c.set_radius 5
puts c.area
</pre>

<p>
In the code example, we have a Circle class. We define two methods.
</p>

<pre class="explanation">
@@PI = 3.141592
</pre>

<p>
We have defined a <code>@@PI</code> variable in our <code>Circle</code> class. 
It is a class variable. Class variables start with <code>@@</code> sigils in Ruby. 
Class variables belong to a class, not to an object. Each object has access to 
its class variables. We use the <code>@@PI</code> to compute the area of the circle. 
</p>

<pre class="explanation">
def initialize
    @radius = 0
end
</pre>

<p>
We have one member field. It is the radius of the circle. If we
want to modify this variable from the outside, we must use
the publicly available <code>set_radius</code> method. 
The data is protected. 
</p>

<pre class="explanation">
def set_radius radius
    @radius = radius
end
</pre>

<p>
This is the <code>set_radius</code> method. It gives the <code>@radius</code> 
instance variable a new value. 
</p>

<pre class="explanation">
def area
    @radius * @radius * @@PI
end
</pre>

<p>
The area method returns the area of a circle. This is a typical task 
for a method. It works with data and produces some value for us.
</p>

<pre class="explanation">
c = Circle.new
c.set_radius 5
puts c.area
</pre>

<p>
We create an instance of the Circle class, and set its radius by 
calling the <code>set_radius</code> method on the object of the circle. 
We use the dot operator to call the method.
</p>

<pre>
$ ./circle.rb
78.5398
</pre>

<p>
Running the example we get this output. 
</p>


<h2>Access modifiers</h2>

<p>
Access modifiers set the visibility of methods and member fields. 
Ruby has three access modifiers: <code>public</code>, <code>protected</code>
and <code>private</code>. In Ruby, all data members are private. Access modifiers
can be used only on methods. Ruby methods are public, unless we say otherwise.
</p>

<p>
The <code>public</code> methods can be accessed from inside the definition of the class
as well as from the outside of the class. The difference between the <code>protected</code> and
the <code>private</code> methods is subtle. Neither can be accessed outside the definition
of the class. They can be accessed only within the class itself and by inherited or parent classes. 
</p>

<p>
Note that unlike in other object-oriented programming languages, <em>inheritance does
not play role</em> in Ruby access modifiers. Only two things are important. First, if we call
the method inside or outside the class definition. Second, if we use or do not use
the <code>self</code> keyword which points to the current receiver. 
</p>

<p>
Access modifiers protect data against accidental modifications. They make 
the programs more robust. The implementation of some methods is subject to change.
These methods are good candidates for being private. The interface that is made public
to the users should only change when really necessary. Over the years users are 
accustomed to using specific methods and breaking backward compatibility is generally
frowned upon.
</p>

<pre class="code">
#!/usr/bin/ruby

class Some
        
     def method1
         puts "public method1 called"
     end

    public
    
     def method2
         puts "public method2 called"  
     end
     
     def method3
         puts "public method3 called"
         method1
         self.method1
     end          
end

s = Some.new
s.method1
s.method2
s.method3
</pre>

<p>
The example explains the usage of public Ruby methods. 
</p>

<pre class="explanation">
def method1
    puts "public method1 called"
end
</pre>

<p>
The method1 is public, even if we did not specify the
<code>public</code> access modifier. It is because methods
are public by default if not specified otherwise.
</p>

<pre class="explanation">
public

  def method2
      puts "public method2 called"  
  end

  ...
</pre>

<p>
Methods following the <code>public</code> keyword are public. 
</p>

<pre class="explanation">
def method3
    puts "public method3 called"
    method1
    self.method1
end    
</pre>

<p>
From inside the public <code>method3</code>, we call other public method,
with and without the <code>self</code> keyword.
</p>

<pre class="explanation">
s = Some.new
s.method1
s.method2
s.method3
</pre>

<p>
Public methods are the only methods that can be called
outside the definition of a class as shown here. 
</p>

<pre>
$ ./public_methods.rb
public method1 called
public method2 called
public method3 called
public method1 called
public method1 called
</pre>

<p>
Running the example we have this output.
</p>

<p>
The next example looks at private methods. 
</p>

<pre class="code">
#!/usr/bin/ruby


class Some
    
    def initialize
        method1
        # self.method1
    end

    private
    
     def method1
         puts "private method1 called"  
     end
           
end


s = Some.new
# s.method1
</pre>

<p>
Private methods are tightest methods in Ruby. They can be called only inside
a class definition and without the <code>self</code> keyword. 
</p>

<pre class="explanation">
def initialize
    method1
    # self.method1
end
</pre>

<p>
In the constructor of the method, we call the private <code>method1</code>. 
Calling the method with the self is commented. Private methods cannot be
specified with a receiver. 
</p>

<pre class="explanation">
private

  def method1
      puts "private method1 called"  
  end
</pre>

<p>
Methods following the <code>private</code> keyword are private in Ruby.
</p>

<pre class="explanation">
s = Some.new
# s.method1
</pre>

<p>
We create an instance of the Some class. Calling the method outside the 
class definition is prohibited. If we uncomment the line, the Ruby interpreter
gives an error. 
</p>

<pre>
$ ./private_methods.rb
private method called
</pre>

<p>
Output of the example code. 
</p>

<p>
Finally, we will work with protected methods. The distinction
between protected and private methods in Ruby is subtle. Protected methods are 
like private. There is only one small difference. They can be called with the 
<code>self</code> keyword specified. 
</p>

<pre class="code">
#!/usr/bin/ruby

class Some
    
    def initialize
        method1
        self.method1
    end

    protected
    
     def method1
         puts "protected method1 called"  
     end
           
end


s = Some.new
# s.method1
</pre>

<p>
The above example shows protected method in usage. 
</p>

<pre class="explanation">
def initialize
    method1
    self.method1
end
</pre>

<p>
Protected methods can be called with and without the <code>self</code> keyword.
</p>

<pre class="explanation">
protected

  def method1
      puts "protected method1 called"  
  end
</pre>

<p>
Protected methods are preceded by the <code>protected</code> keyword.
</p>

<pre class="explanation">
s = Some.new
# s.method1
</pre>

<p>
Protected methods cannot be called outside the class definition.
Uncommenting the line would lead to an error. 
</p>


<h2>Inheritance</h2>

<p>
Inheritance is a way to form new classes using classes 
that have already been defined. The newly formed classes are 
called <em>derived</em> classes, the classes that we derive from
are called <em>base</em> classes. Important benefits of inheritance 
are code reuse and reduction of complexity of a program. The 
derived classes (descendants) override or extend the functionality 
of base classes (ancestors). 
</p>

<pre class="code">
#!/usr/bin/ruby

class Being

    def initialize
        puts "Being class created"
    end
end

class Human &lt; Being

   def initialize
       super
       puts "Human class created"
   end
end

Being.new
Human.new
</pre>

<p>
In this program, we have two classes: a base <code>Being</code> class and a 
derived <code>Human</code> class. The derived class inherits from the 
base class. 
</p>

<pre class="explanation">
class Human &lt; Being
</pre>

<p> 
In Ruby, we use the <code>&lt;</code> operator to create inheritance 
relations. The <code>Human</code> class inherits from the 
<code>Being</code> class. 
</p>

<pre class="explanation">
def initialize
    super
    puts "Human class created"
end
</pre>

<p>
The <code>super</code> method calls the constructor of the
parent class. 
</p>

<pre class="explanation">
Being.new
Human.new
</pre>

<p>
We instantiate the <code>Being</code> and the <code>Human</code> class. 
</p>

<pre>
$ ./inheritance.rb 
Being class created
Being class created
Human class created
</pre>

<p>
First the <code>Being</code> class is created. The derived 
<code>Human</code> class also calls the constructor of its parent.
</p>

<p>
An Object may be involved in complicated relationships. 
A single object can have multiple ancestors. Ruby has
a method <code>ancestors</code> which gives a list of
ancestors for a specific class. 
</p>

<p>
Each Ruby object is automatically a descendant of <code>Object</code> 
and <code>BasicObject</code> classes and  of the <code>Kernel</code> 
module. They are built-in the core of the Ruby language. 
</p>

<pre class="code">
#!/usr/bin/ruby


class Being 
end

class Living &lt; Being 
end

class Mammal &lt; Living 
end

class Human &lt; Mammal 
end
    
    
p Human.ancestors
</pre>

<p>
We have four classes in this example: a <code>Human</code> is a <code>Mammal</code> 
a <code>Living</code> and a <code>Being</code>. 
</p>

<pre class="explanation">
p Human.ancestors
</pre>

<p>
We print the ancestors of a Human class. 
</p>

<pre>
$ ./ancestors.rb 
[Human, Mammal, Living, Being, Object, Kernel, BasicObject]
</pre>

<p>
A Human class has three custom and three built-in ancestors. 
</p>

<p>
A more complex example follows. 
</p>

<pre class="code">
#!/usr/bin/ruby

class Being
    
    @@count = 0

    def initialize
        @@count += 1
        puts "Being class created"
    end
    
    def show_count
        "There are #{@@count} beings"
    end
    
end

class Human &lt; Being

   def initialize
       super
       puts "Human is created"
   end
end

class Animal &lt; Being

   def initialize
       super
       puts "Animal is created"
   end
end

class Dog &lt; Animal

   def initialize
       super
       puts "Dog is created"
   end
end

Human.new
d = Dog.new
puts d.show_count
</pre>

<p>
We have four classes. The inheritance hierarchy is more complicated. The
<code>Human</code> and the <code>Animal</code> classes inherit from the 
<code>Being</code> class. And the <code>Dog</code> class inherits directly
from the <code>Animal</code> class and further from the <code>Being</code> 
class. We also use a class variable to count the number of beings created.
</p>

<pre class="explanation">
@@count = 0
</pre>

<p>
We define a class variable. A class variable begins with <code>@@</code> 
sigils and it belongs to the class, not to the instance of the class. We 
use it to count the number of beings created.
</p>

<pre class="explanation">
def initialize
    @@count += 1
    puts "Being class created"
end
</pre>

<p>
Each time the <code>Being</code> class is instantiated, we increase the 
<code>@@count</code> variable by one. This way we keep track of the number 
of instances created.
</p>

<pre class="explanation">
class Animal &lt; Being
...

class Dog &lt; Animal
...
</pre>

<p>
The <code>Animal</code> inherits from the <code>Being</code> and the 
<code>Dog</code> inherits from the <code>Animal</code>. Further, the 
<code>Dog</code> inherits from the <code>Being</code> as well. 
</p>

<pre class="explanation">
Human.new
d = Dog.new
puts d.show_count
</pre>

<p>
We create instances from the <code>Human</code> and from the <code>Dog</code> 
classes. We call the <code>show_count</code> method on the <code>Dog</code> object. 
The <code>Dog</code> class has no such method; the grandparent's (Being's) 
method is called then.
</p>

<pre>
$ ./inheritance2.rb
Being class created
Human is created
Being class created
Animal is created
Dog is created
There are 2 beings
</pre>

<p>
The Human object calls two constructors. The <code>Dog</code> object 
calls three constructors. There are two beings instantiated.
</p>


<p>
Inheritance does not play role in the visibility of methods and 
data members. This is a notable difference from many common
object-oriented programming languages. 
</p>

<p>
In C# or Java, public and protected data members and methods are inherited; 
private data members and methods are not. In contrast to this, private data 
members and methods are inherited in Ruby as well. The visibility of data members 
and methods is not affected by inheritance in Ruby.
</p>

<pre class="code">
#!/usr/bin/ruby

class Base
    
    def initialize
        @name = "Base"
    end
    
    private
     
     def private_method
         puts "private method called"
     end
     
    protected
    
     def protected_method
         puts "protected_method called"
     end

    public
         
     def get_name
         return @name
     end
end


class Derived &lt; Base

    def public_method
        private_method
        protected_method
    end
end

d = Derived.new
d.public_method
puts d.get_name
</pre>

<p>
In the example we have two classes. The <code>Derived</code> class 
inherits from the <code>Base</code> class. It inherits all three methods 
and one data field. 
</p>

<pre class="explanation">
def public_method
    private_method
    protected_method
end
</pre>

<p> 
In the public_method of the <code>Derived</code> class we call one private and
one protected method. They were defined in the parent class. 
</p>

<pre class="explanation">
d = Derived.new
d.public_method
puts d.get_name
</pre>

<p>
We create an instance of the <code>Derived</code> class. We call <code>public_method</code>, 
as well as also <code>get_name</code>, which returns the private <code>@name</code> variable.
Remember that all instance variables are private in Ruby. 
The get_name method returns the variable, regardless of @name's being private 
and defined in the parent class.
</p>

<pre>
$ ./inheritance3.rb
private method called
protected_method called
Base
</pre>

<p>
The output of the example confirms that in Ruby language, 
public, protected, private methods and private member fields 
are inherited by child objects from their parents.
</p>


<h2>The super method</h2>

<p>
The <code>super</code> method calls a method of the same 
name in the parent's class. If the method has no arguments
it automatically passes all its arguments. If we write 
<code>super()</code> no arguments are passed to parent's 
method.
</p>


<pre class="code">
#!/usr/bin/ruby

class Base
   
    def show x=0, y=0
        p "Base class, x: #{x}, y: #{y}"
    end
end

class Derived &lt; Base

    def show x, y
        super
        super x
        super x, y
        super()
    end
end


d = Derived.new
d.show 3, 3
</pre>

<p>
In the example, we have two classes in a hierarchy. They both
have a show method. The show method in the Derived class calls
the show method in the Base class using the <code>super</code> 
method. 
</p>

<pre class="explanation">
def show x, y
    super
    super x
    super x, y
    super()
end
</pre>

<p>
The <code>super</code> method without any arguments calls the 
parent's show method with the arguments that were passed to the
show method of the <code>Derived</code> class: here, x=3 and y=3.
The <code>super()</code> method passes no arguments to the 
parent's show method.
</p>


<pre>
$ ./super.rb
"Base class, x: 3, y: 3"
"Base class, x: 3, y: 0"
"Base class, x: 3, y: 3"
"Base class, x: 0, y: 0"
</pre>

<p>
This is the output of the example.
</p>


<p>
This was the first part of the description of OOP in Ruby.
</p>


<div class="big_hor">
<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- big_horizontal -->
<ins class="adsbygoogle"
     style="display:inline-block;width:728px;height:90px"
     data-ad-client="ca-pub-9706709751191532"
     data-ad-slot="2904953388"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>

<footer>

<nav>
<a href="/">Home</a>
<a href="..">Contents</a> 
<a href="#">Top of Page</a>

<div class="nav_r">
<a href="../hashes/">Previous</a>
<a href="../oop2/">Next</a>
</div>
</nav>


<div class="signature">
<a href="/">ZetCode</a> last modified October 3, 2014  <span class="copyright">&copy; 2007 - 2016 Jan Bodnar</span>
</div>

</footer>

</div> <!-- content -->

</div> <!-- container -->

<!-- Silktide Cookie -->
<script>
    window.cookieconsent_options = {"message":"This website uses cookies to ensure you get the best experience on our website",
    "dismiss":"Got it!","learnMore":"More info","link":null,"theme":"dark-floating"};
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/1.0.9/cookieconsent.min.js"></script>

</body> 
</html>

